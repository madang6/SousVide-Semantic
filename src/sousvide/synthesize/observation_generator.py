import numpy as np
import os
import torch

from typing import Dict,Union,List

import sousvide.synthesize.data_utils as du

from sousvide.control.pilot import Pilot

def generate_observation_data(cohort:str,roster:List[str],subsample:float=1.0,validation_mode:bool=False) -> None:
    """
    Takes rollout data and generates observations for each pilot in the cohort. The observations are
    generated by running the rollout data through the pilot's OODA function. The observations are saved
    to a .pt file in the pilot's directory.

    """
    
    # Generate some useful paths
    workspace_path = os.path.dirname(
        os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
    cohort_path = os.path.join(workspace_path,"cohorts",cohort)
    rollout_folder_path = os.path.join(cohort_path,"rollout_data")

    # Initialize Pilots
    Pilots = [Pilot(cohort,name) for name in roster]
    
    print("==========================================================================================")

    for pilot in Pilots:
        # Print some useful information
        print(f"Pilot Name  : {pilot.name}")
        print(f"Augmentation: {pilot.da_cfg['mean']}")
        print( "            :                        +/-")
        print(f"            : {pilot.da_cfg['std']}")
        print(f"Subsample   : 1 in {int(1/subsample)}")
        print("------------------------------------------------------------------------------------------")

        # Get Course Folders
        courses = [folder for folder in os.listdir(rollout_folder_path)]
        
        Nobs = 0
        if validation_mode:
            for course in courses:
                # Load Trajectory Data
                rollout_data_path = os.path.join(rollout_folder_path,course)
                trajectory_data_files = sorted([
                    file for file in os.listdir(rollout_data_path)
                    if file.startswith("trajectories_val") and file.endswith(".pt")])
                image_data_files = sorted([
                    file for file in os.listdir(rollout_data_path)
                    if file.startswith("imgdata_val") and file.endswith(".pt")])
                video_data_files = sorted([
                    os.path.join(rollout_data_path, file) for file in os.listdir(rollout_data_path)
                    if file.startswith("video_val") and file.endswith(".mp4")])
                
                # Generate Observation Data (sans images)
                for trajectory_data_file,image_data_file,video in zip(trajectory_data_files,image_data_files,video_data_files):
                    trajectory_data_set = torch.load(os.path.join(rollout_data_path,trajectory_data_file))
                    image_data_set = torch.load(os.path.join(rollout_data_path,image_data_file))
                    observations = generate_observations(pilot,trajectory_data_set,image_data_set,video,subsample)
                    Nobs += observations["Nobs"]

                    # Save the observations
                    save_observations(cohort_path,course,pilot.name,observations,validation_mode)
        else:
            for course in courses:
                # Load Trajectory Data
                rollout_data_path = os.path.join(rollout_folder_path,course)
                trajectory_data_files = sorted([
                    file for file in os.listdir(rollout_data_path)
                    if file.startswith("trajectories") and file.endswith(".pt")])
                image_data_files = sorted([
                    file for file in os.listdir(rollout_data_path)
                    if file.startswith("img") and file.endswith(".pt")])
                video_data_files = sorted([
                    os.path.join(rollout_data_path, file) for file in os.listdir(rollout_data_path)
                    if file.startswith("video") and file.endswith(".mp4")])
                
                # Generate Observation Data (sans images)
                for trajectory_data_file,image_data_file,video in zip(trajectory_data_files,image_data_files,video_data_files):
                    trajectory_data_set = torch.load(os.path.join(rollout_data_path,trajectory_data_file))
                    image_data_set = torch.load(os.path.join(rollout_data_path,image_data_file))
                    observations = generate_observations(pilot,trajectory_data_set,image_data_set,video,subsample)
                    Nobs += observations["Nobs"]

                    # Save the observations
                    save_observations(cohort_path,course,pilot.name,observations)

        print("Data Counts ------------------------------------------------------------------------------")
        print("Extracted",Nobs,"observations from",len(courses),"course(s).")
    print("==========================================================================================")


def generate_observations(pilot:Pilot,
                            trajectory_data_set:Dict[str,Union[str,int,Dict[str,Union[np.ndarray,float,str]]]],
                            image_data_set:Dict[str,Union[str,int,Dict[str,Union[np.ndarray,float,str]]]],
                            video,
                            subsample:float=1) -> Dict[str,Union[str,int,Dict[str,Union[np.ndarray,float,str]]]]:
    
    # Initialize the observation data dictionary
    Observations, Img_Obsv = [], []

    # Unpack augmenteation variables
    aug_type = np.array(pilot.da_cfg["type"])
    aug_mean = np.array(pilot.da_cfg["mean"])
    aug_std = np.array(pilot.da_cfg["std"])

    # Set subsample step
    nss = int(1/subsample)

    # Generate observations
    Nobs = 0
    for trajectory_data,image_data in zip(trajectory_data_set["data"],image_data_set["data"]):
        # Unpack data
        Tro,Xro,Uro = trajectory_data["Tro"],trajectory_data["Xro"],trajectory_data["Uro"]
        obj,Ndata = trajectory_data["obj"],trajectory_data["Ndata"]
        rollout_id,course = trajectory_data["rollout_id"],trajectory_data["course"]
        frame = trajectory_data["frame"]

        # Decompress and extract the image data
        # Imgs = du.decompress_data(image_data)["images"]
        Imgs = du.load_video_frames(video,image_data)

        # Check if images are raw or processed. Raw images are in (N,H,W,C) format while
        # processed images are in (N,C,H,W) format.
        height,width = Imgs.shape[1],Imgs.shape[2]

        if height == 224 and width == 224:
            Imgs = np.transpose(Imgs, (0, 3, 1, 2))

        # Create Rollout Data
        Xnn,Ynn,Obsv = [],[],[]
        upr = np.zeros(4)
        znn_cr = torch.zeros(pilot.model.Nz).to(pilot.device)
        for k in range(Ndata):
            # Generate current state (with/without noise augmentation)
            if aug_type == "additive":
                xcr = Xro[:,k] + np.random.normal(aug_mean,aug_std)
            elif aug_type == "multiplicative":
                xcr = Xro[:,k] * (1 + np.random.normal(aug_mean,aug_std))
            else:
                xcr = Xro[:,k]

            # Extract other data
            tcr = Tro[k]
            ucr = Uro[:,k]
            img_cr = Imgs[k,:,:,:]

            # Generate the sfti data
            _,znn_cr,_,xnn,_ = pilot.OODA(upr,tcr,xcr,obj,img_cr,znn_cr)
            ynn = {"unn":ucr,"mfn":np.array([frame["mass"],frame["force_normalized"]]),"onn":xcr}

            # Store the data
            if k % nss == 0:
                Xnn.append(xnn)
                Ynn.append(ynn)

            # Loop updates
            upr = ucr

        # Store the observation data
        observations = {
            "Xnn":Xnn,
            "Ynn":Ynn,
            "Ndata":len(Xnn),
            "rollout_id":rollout_id,
            "course":course,"frame":frame
        }
        Observations.append(observations)
        Nobs += len(Xnn)

    observations_data_set = {"data":Observations,
                    "set":trajectory_data_set["set"],
                    "Nobs":Nobs,
                    "course":trajectory_data_set["course"]}

    return observations_data_set


def save_observations(cohort_path:str,course_name:str,
                      pilot_name:str,
                      observations:Dict[str,Union[np.ndarray,int,str]],
                      validation_mode:bool=False) -> None:
    
    """
    Saves the observation data to a .pt file in folders corresponding to pilot name within the course
    directory within the cohort directory.

    Args:
        cohort_path:    Cohort path.
        course_name:    Name of the course.
        pilot_name:     Name of the pilot.
        observations:   Observation data.

    Returns:
        None:           (observation data saved to cohort directory)
    """

    # Create observation course directory (if it does not exist)
    observation_pilot_path = os.path.join(cohort_path,"observation_data",pilot_name)
    if not os.path.exists(observation_pilot_path):
        os.makedirs(observation_pilot_path)

    observation_course_path = os.path.join(observation_pilot_path,course_name)
    if not os.path.exists(observation_course_path):
        os.makedirs(observation_course_path)

    
    if validation_mode:
        observations_data_path = os.path.join(
            observation_course_path,"observations_val"+str(observations["set"])+".pt")
    else:
        # Save the observations
        observations_data_path = os.path.join(
            observation_course_path,"observations"+str(observations["set"])+".pt")

    torch.save(observations,observations_data_path)